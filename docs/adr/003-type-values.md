# ADR 003: Type Values
**Date:** 13/12/2025
**Status:** Accepted

## Summary

This ADR specifies the formats and units for all W3C DTCG token types, ensuring cross-platform compatibility and predictable transformations. We use **absolute units in primitives** (HEX for colors, px for dimensions) as the source of truth, enabling platform-specific transforms during build (px→rem for web, px→pt for iOS, px→dp for Android). This approach maintains tool compatibility (Figma, Style Dictionary) while supporting accessibility through responsive transforms.

**Key Decision**: HEX colors and px dimensions in primitives, with automated transforms to platform-specific formats. Unitless line heights, numeric font weights, and milliseconds for durations ensure consistent cross-platform behavior.

## Context and Problem

Design tokens must use consistent formats and units for their values to ensure:
- Cross-platform compatibility (Web, iOS, Android)
- Tool interoperability (Style Dictionary, Figma, Tokens Studio)
- Accessibility and scalability
- Maintainability and predictable transforms

Each W3C DTCG token type (color, dimension, typography, etc.) can be represented in multiple formats. We must decide which format/unit to use as the **source of truth** in our primitive tokens, and how to transform them for different platforms.

**Example questions**:
- Colors: HEX, RGB, HSL, or OKLCH?
- Dimensions (spacing, fontSize, etc.): px, rem, or em?
- Line heights: unitless or with units?
- Durations: ms or seconds?

Without clear decisions, teams will:
- Use inconsistent formats across tokens
- Have difficulty transforming tokens to platform-specific outputs
- Struggle with tool compatibility
- Create accessibility issues

## Decision Criteria

- **W3C DTCG 2025.10 compliance**: Follow specification standards
- **CSS standards alignment**: Match modern CSS best practices
- **Tool compatibility**: Work seamlessly with Style Dictionary, Figma, Tokens Studio
- **Platform compatibility**: Enable transforms to Web (CSS), iOS, Android
- **Accessibility**: Support user preferences and responsive scaling
- **Maintainability**: Predictable, consistent transform strategies
- **Future-proof**: Prepare for evolving standards (e.g., CSS Color Module Level 4)

---

## Token Type Formats

### 1. Color Type

**DTCG Type**: `color`
**Applicable to**: `primitive.color.*`, `semantic.color.*`

#### Format Decision

Primitive colors MUST be defined in **HEX format** as the source of truth:

```json
{
  "primitive": {
    "color": {
      "blue": {
        "500": {
          "$type": "color",
          "$value": "#3b82f6"
        }
      }
    }
  }
}
```

**Format**: `#RRGGBB` or `#RRGGBBAA` (with alpha)

**Additional formats** (optional, can be generated):
- **HSL**: `hsl(H, S%, L%)` - for human-readable color adjustments
- **OKLCH**: `oklch(L% C H)` - for perceptually uniform color spaces (CSS Color Module Level 4)

#### Rationale

**Why HEX**:
- ✅ **Maximum tool compatibility**: Native format for Figma, Sketch, Adobe XD
- ✅ **Compact**: Shorter than RGB/HSL
- ✅ **Universal**: Understood by all platforms
- ✅ **Easy transforms**: Can generate HSL, RGB, OKLCH from HEX
- ✅ **Alpha support**: 8-digit HEX supports transparency

**Why provide HSL/OKLCH** (optional):
- HSL enables intuitive adjustments (lightness, saturation)
- OKLCH provides perceptual uniformity for accessible palettes
- Can be generated by Style Dictionary transforms

#### Platform Transforms

| Platform | Transform | Output Format |
|----------|-----------|---------------|
| Web (CSS) | Direct use or convert to rgb()/hsl()/oklch() | `#3b82f6` or `rgb(59, 130, 246)` |
| iOS | Convert to UIColor | `UIColor(red: 59/255, green: 130/255, blue: 246/255, alpha: 1)` |
| Android | Convert to Color resource | `#3b82f6` |

#### Examples

```json
{
  "primitive": {
    "color": {
      "$type": "color",
      "blue": {
        "50": { "$value": "#eff6ff" },
        "500": { "$value": "#3b82f6" },
        "900": { "$value": "#1e3a8a" }
      },
      "primary": {
        "600": { "$value": "#2563eb", "$description": "Primary brand color" }
      }
    }
  }
}
```

---

### 2. Dimension Type

**DTCG Type**: `dimension`
**Applicable to**: `primitive.spacing.*`, `primitive.fontSize.*`, `primitive.borderRadius.*`, `primitive.borderWidth.*`, `semantic.spacing.*`, `semantic.radius.*`, `semantic.borderWidth.*`

#### Format Decision

All dimensional values MUST use **pixels (px)** as the primitive unit:

```json
{
  "primitive": {
    "spacing": {
      "$type": "dimension",
      "md": {
        "$value": "16px"
      }
    },
    "fontSize": {
      "$type": "dimension",
      "xl": {
        "$value": "20px"
      }
    }
  }
}
```

**Format**: `{number}px`

#### Rationale

**Why pixels**:
- ✅ **Absolute values**: Primitives use absolute units for predictable transforms
- ✅ **Figma alignment**: Figma uses px as its native unit system
- ✅ **Platform agnostic**: Can transform to any platform unit (rem, pt, dp)
- ✅ **Consistent base**: Single source of truth for all dimensional values
- ✅ **Transform flexibility**: Style Dictionary easily converts px → rem, pt, dp

**Why NOT rem in primitives**:
- ❌ Primitives should be absolute, transforms make them relative
- ❌ Different platforms need different relative units (rem for web, pt for iOS, dp for Android)
- ❌ Harder to maintain consistency across platforms

#### Platform Transforms

| Platform | Transform | Output Format | Example |
|----------|-----------|---------------|---------|
| Web (CSS) | Divide by 16 (base font size) | `{number}rem` | `16px` → `1rem` |
| iOS | Direct use as points | `{number}` | `16px` → `16 pt` |
| Android | Direct use as dp | `{number}dp` | `16px` → `16dp` |

#### Examples

**Spacing**:
```json
{
  "primitive": {
    "spacing": {
      "$type": "dimension",
      "xs": { "$value": "4px" },
      "sm": { "$value": "8px" },
      "md": { "$value": "16px" },
      "lg": { "$value": "24px" },
      "xl": { "$value": "32px" }
    }
  }
}
```

**Font Size**:
```json
{
  "primitive": {
    "fontSize": {
      "$type": "dimension",
      "sm": { "$value": "14px" },
      "md": { "$value": "16px" },
      "lg": { "$value": "18px" },
      "xl": { "$value": "20px" },
      "2xl": { "$value": "24px" }
    }
  }
}
```

**Border Radius**:
```json
{
  "primitive": {
    "borderRadius": {
      "$type": "dimension",
      "none": { "$value": "0px" },
      "sm": { "$value": "4px" },
      "md": { "$value": "8px" },
      "lg": { "$value": "12px" },
      "full": { "$value": "9999px" }
    }
  }
}
```

---

### 3. Font Family Type

**DTCG Type**: `fontFamily`
**Applicable to**: `primitive.fontFamily.*`

#### Format Decision

Use **array of font family names** with fallbacks:

```json
{
  "primitive": {
    "fontFamily": {
      "$type": "fontFamily",
      "sans": {
        "$value": ["Inter", "system-ui", "-apple-system", "sans-serif"]
      }
    }
  }
}
```

**Format**: Array of strings `["Primary", "Fallback1", "Fallback2", "Generic"]`

**Alternative**: Single string format also valid per DTCG spec:
```json
{ "$value": "Inter, system-ui, -apple-system, sans-serif" }
```

#### Rationale

**Why array**:
- ✅ **DTCG recommended format**: Specification prefers array
- ✅ **Explicit fallbacks**: Clear fallback chain
- ✅ **Tool compatibility**: Most tools support array format
- ✅ **Platform transforms**: Easy to convert to platform-specific format

#### Platform Transforms

| Platform | Transform | Output Format |
|----------|-----------|---------------|
| Web (CSS) | Join with commas | `"Inter", system-ui, -apple-system, sans-serif` |
| iOS | Use first available font | `UIFont(name: "Inter", size: ...)` |
| Android | Use first available font | `fontFamily="Inter"` |

#### Examples

```json
{
  "primitive": {
    "fontFamily": {
      "$type": "fontFamily",
      "sans": {
        "$value": ["Inter", "system-ui", "-apple-system", "BlinkMacSystemFont", "Segoe UI", "Roboto", "sans-serif"],
        "$description": "Default sans-serif font stack"
      },
      "serif": {
        "$value": ["Georgia", "Cambria", "Times New Roman", "serif"],
        "$description": "Serif font stack"
      },
      "mono": {
        "$value": ["Fira Code", "Consolas", "Monaco", "Courier New", "monospace"],
        "$description": "Monospace font stack"
      }
    }
  }
}
```

---

### 4. Font Weight Type

**DTCG Type**: `fontWeight`
**Applicable to**: `primitive.fontWeight.*`

#### Format Decision

Use **numeric values** (100-900):

```json
{
  "primitive": {
    "fontWeight": {
      "$type": "fontWeight",
      "normal": {
        "$value": 400
      },
      "bold": {
        "$value": 700
      }
    }
  }
}
```

**Format**: Integer from 100 to 900 in increments of 100

**Valid values**: `100, 200, 300, 400, 500, 600, 700, 800, 900`

**Alternative**: String keywords also valid per DTCG:
- `"normal"` (equivalent to 400)
- `"bold"` (equivalent to 700)

However, **numeric format is preferred**.

#### Rationale

**Why numeric**:
- ✅ **Universal**: Works across all platforms
- ✅ **Variable font support**: Enables fine-grained weight control
- ✅ **CSS standard**: Direct mapping to `font-weight` property
- ✅ **Consistent**: Single format across all uses

#### Platform Transforms

| Platform | Transform | Output Format |
|----------|-----------|---------------|
| Web (CSS) | Direct use | `font-weight: 700` |
| iOS | Map to UIFont.Weight | `.regular`, `.bold`, etc. |
| Android | Map to font weight | `android:textStyle="bold"` |

#### Examples

```json
{
  "primitive": {
    "fontWeight": {
      "$type": "fontWeight",
      "thin": { "$value": 100 },
      "extralight": { "$value": 200 },
      "light": { "$value": 300 },
      "normal": { "$value": 400 },
      "medium": { "$value": 500 },
      "semibold": { "$value": 600 },
      "bold": { "$value": 700 },
      "extrabold": { "$value": 800 },
      "black": { "$value": 900 }
    }
  }
}
```

---

### 5. Line Height Type

**DTCG Type**: `number`
**Applicable to**: `primitive.lineHeight.*`

#### Format Decision

Use **unitless multipliers**:

```json
{
  "primitive": {
    "lineHeight": {
      "$type": "number",
      "tight": {
        "$value": 1.25
      },
      "normal": {
        "$value": 1.5
      }
    }
  }
}
```

**Format**: Decimal number (e.g., `1.5`)

**Do NOT use**: px, rem, em, or percentage

#### Rationale

**Why unitless**:
- ✅ **CSS best practice**: Recommended by CSS specification
- ✅ **Proportional scaling**: Scales automatically with font size
- ✅ **Platform agnostic**: Works across all platforms
- ✅ **Predictable**: Avoids inheritance issues

#### Platform Transforms

| Platform | Transform | Output Format |
|----------|-----------|---------------|
| Web (CSS) | Direct use | `line-height: 1.5` |
| iOS | Multiply by font size | `lineHeight = fontSize * 1.5` |
| Android | Multiply by font size | `lineSpacingMultiplier="1.5"` |

#### Examples

```json
{
  "primitive": {
    "lineHeight": {
      "$type": "number",
      "none": { "$value": 1, "$description": "Tight line height, no extra spacing" },
      "tight": { "$value": 1.25, "$description": "Tight line height for headings" },
      "snug": { "$value": 1.375, "$description": "Slightly tighter than normal" },
      "normal": { "$value": 1.5, "$description": "Standard line height for body text" },
      "relaxed": { "$value": 1.625, "$description": "Relaxed line height" },
      "loose": { "$value": 2, "$description": "Loose line height for readability" }
    }
  }
}
```

---

### 6. Letter Spacing Type

**DTCG Type**: `dimension`
**Applicable to**: `primitive.letterSpacing.*`

#### Format Decision

Use **pixels (px)** as primitive value:

```json
{
  "primitive": {
    "letterSpacing": {
      "$type": "dimension",
      "tight": {
        "$value": "-0.5px"
      },
      "wide": {
        "$value": "1px"
      }
    }
  }
}
```

**Format**: `{number}px` (can be negative)

#### Rationale

**Why pixels**:
- ✅ **Consistent with dimensions**: Same strategy as spacing/fontSize
- ✅ **Figma alignment**: Figma uses px for letter spacing
- ✅ **Absolute primitive**: Can transform to relative units (em) for web

**Why NOT em in primitives**:
- Letter spacing should scale with font size (em), but primitives should be absolute
- Transform to em during build for web platform

#### Platform Transforms

| Platform | Transform | Output Format | Conversion |
|----------|-----------|---------------|------------|
| Web (CSS) | Divide by font size (usually 16px) then convert to em | `{number}em` | `1px` → `0.0625em` (1/16) |
| iOS | Direct use as points | `{number}` | `1px` → `1 pt` |
| Android | Direct use | `{number}` | `1px` → `1dp` |

#### Examples

```json
{
  "primitive": {
    "letterSpacing": {
      "$type": "dimension",
      "tighter": { "$value": "-0.05em" },
      "tight": { "$value": "-0.025em" },
      "normal": { "$value": "0em" },
      "wide": { "$value": "0.025em" },
      "wider": { "$value": "0.05em" },
      "widest": { "$value": "0.1em" }
    }
  }
}
```

**Note**: While primitives could use px, providing em values directly is also acceptable for letter-spacing since it's inherently relative to font size. The key is consistency.

---

### 7. Typography Type (Composite)

**DTCG Type**: `typography`
**Applicable to**: `semantic.typography.*`

#### Format Decision

Use **composite object** combining multiple typography properties:

```json
{
  "semantic": {
    "typography": {
      "$type": "typography",
      "h1": {
        "$value": {
          "fontFamily": "{primitive.fontFamily.sans}",
          "fontSize": "{primitive.fontSize.3xl}",
          "fontWeight": "{primitive.fontWeight.bold}",
          "lineHeight": "{primitive.lineHeight.tight}",
          "letterSpacing": "{primitive.letterSpacing.tight}"
        }
      }
    }
  }
}
```

**Format**: Object with required and optional properties

**Required properties**:
- `fontFamily`
- `fontSize`
- `fontWeight`
- `lineHeight`

**Optional properties**:
- `letterSpacing`
- `textTransform`
- `textDecoration`

#### Rationale

**Why composite**:
- ✅ **Complete styles**: Defines all typography attributes together
- ✅ **DTCG standard**: Specification defines typography as composite type
- ✅ **References primitives**: Builds on primitive tokens
- ✅ **Semantic layer**: Typography tokens are semantic, not primitive

#### Platform Transforms

| Platform | Transform | Output Format |
|----------|-----------|---------------|
| Web (CSS) | Expand to individual properties | `font-family: ...; font-size: ...; font-weight: ...; line-height: ...; letter-spacing: ...` |
| iOS | Create text style | `UIFont.TextStyle` or custom text style |
| Android | Create text appearance | `TextAppearance` style |

#### Examples

```json
{
  "semantic": {
    "typography": {
      "$type": "typography",
      "display": {
        "$value": {
          "fontFamily": "{primitive.fontFamily.sans}",
          "fontSize": "{primitive.fontSize.5xl}",
          "fontWeight": "{primitive.fontWeight.bold}",
          "lineHeight": "{primitive.lineHeight.tight}",
          "letterSpacing": "{primitive.letterSpacing.tight}"
        },
        "$description": "Large display text for hero sections"
      },
      "h1": {
        "$value": {
          "fontFamily": "{primitive.fontFamily.sans}",
          "fontSize": "{primitive.fontSize.3xl}",
          "fontWeight": "{primitive.fontWeight.bold}",
          "lineHeight": "{primitive.lineHeight.tight}",
          "letterSpacing": "{primitive.letterSpacing.normal}"
        },
        "$description": "Main heading level 1"
      },
      "body": {
        "$value": {
          "fontFamily": "{primitive.fontFamily.sans}",
          "fontSize": "{primitive.fontSize.md}",
          "fontWeight": "{primitive.fontWeight.normal}",
          "lineHeight": "{primitive.lineHeight.normal}",
          "letterSpacing": "{primitive.letterSpacing.normal}"
        },
        "$description": "Regular body text"
      }
    }
  }
}
```

---

### 8. Shadow Type (Composite)

**DTCG Type**: `shadow`
**Applicable to**: `semantic.shadow.*`

#### Format Decision

Use **composite object** (single shadow) or **array of objects** (multiple shadows):

**Single shadow**:
```json
{
  "semantic": {
    "shadow": {
      "$type": "shadow",
      "md": {
        "$value": {
          "color": "{primitive.color.black}",
          "offsetX": "0px",
          "offsetY": "4px",
          "blur": "6px",
          "spread": "0px"
        }
      }
    }
  }
}
```

**Multiple shadows (layered)**:
```json
{
  "semantic": {
    "shadow": {
      "lg": {
        "$value": [
          {
            "color": "{primitive.color.black}",
            "offsetX": "0px",
            "offsetY": "10px",
            "blur": "15px",
            "spread": "-3px"
          },
          {
            "color": "{primitive.color.black}",
            "offsetX": "0px",
            "offsetY": "4px",
            "blur": "6px",
            "spread": "-2px"
          }
        ]
      }
    }
  }
}
```

**Format**:
- **Single**: Object with `color`, `offsetX`, `offsetY`, `blur`, `spread`
- **Multiple**: Array of shadow objects

**Properties**:
- `color` (required): Color value or reference
- `offsetX` (required): Horizontal offset (dimension)
- `offsetY` (required): Vertical offset (dimension)
- `blur` (required): Blur radius (dimension)
- `spread` (optional): Spread radius (dimension)

#### Rationale

**Why composite**:
- ✅ **Complete definition**: All shadow properties together
- ✅ **DTCG standard**: Specification defines shadow as composite
- ✅ **Layering support**: Array enables multiple layered shadows
- ✅ **Semantic layer**: Shadows are semantic tokens

#### Platform Transforms

| Platform | Transform | Output Format |
|----------|-----------|---------------|
| Web (CSS) | Convert to box-shadow | `box-shadow: 0px 4px 6px 0px rgba(0,0,0,0.1)` |
| iOS | Create NSShadow | `NSShadow` object |
| Android | Create elevation/shadow | `elevation` attribute |

#### Examples

```json
{
  "semantic": {
    "shadow": {
      "$type": "shadow",
      "sm": {
        "$value": {
          "color": "#0000001a",
          "offsetX": "0px",
          "offsetY": "1px",
          "blur": "2px",
          "spread": "0px"
        },
        "$description": "Small shadow for subtle elevation"
      },
      "md": {
        "$value": {
          "color": "#0000001a",
          "offsetX": "0px",
          "offsetY": "4px",
          "blur": "6px",
          "spread": "-1px"
        },
        "$description": "Medium shadow for cards"
      },
      "lg": {
        "$value": [
          {
            "color": "#0000001a",
            "offsetX": "0px",
            "offsetY": "10px",
            "blur": "15px",
            "spread": "-3px"
          },
          {
            "color": "#00000014",
            "offsetX": "0px",
            "offsetY": "4px",
            "blur": "6px",
            "spread": "-2px"
          }
        ],
        "$description": "Large shadow with multiple layers"
      }
    }
  }
}
```

---

### 9. Duration Type

**DTCG Type**: `duration`
**Applicable to**: `primitive.duration.*`, `semantic.duration.*`

#### Format Decision

Use **milliseconds (ms)**:

```json
{
  "primitive": {
    "duration": {
      "$type": "duration",
      "fast": {
        "$value": "150ms"
      }
    }
  }
}
```

**Format**: `{number}ms`

**Alternative**: Seconds (`{number}s`) also valid per DTCG, but ms is preferred.

#### Rationale

**Why milliseconds**:
- ✅ **Precision**: More precise than seconds for short durations
- ✅ **Common**: Most animation libraries use ms
- ✅ **Easy transform**: Simple to convert to seconds (divide by 1000)
- ✅ **Integer values**: Avoids decimals for short durations

#### Platform Transforms

| Platform | Transform | Output Format |
|----------|-----------|---------------|
| Web (CSS) | Direct use or convert to seconds | `150ms` or `0.15s` |
| iOS | Convert to seconds | `0.15` (TimeInterval) |
| Android | Direct use as milliseconds | `150` (long) |

#### Examples

```json
{
  "primitive": {
    "duration": {
      "$type": "duration",
      "instant": { "$value": "50ms", "$description": "Instant feedback" },
      "fast": { "$value": "150ms", "$description": "Fast transitions" },
      "normal": { "$value": "300ms", "$description": "Standard animations" },
      "slow": { "$value": "500ms", "$description": "Slow, deliberate animations" },
      "slower": { "$value": "800ms", "$description": "Very slow animations" }
    }
  }
}
```

---

### 10. Number Type (Opacity, Z-Index)

**DTCG Type**: `number`
**Applicable to**: `primitive.opacity.*`, `primitive.zIndex.*`, `semantic.opacity.*`

#### Format Decision

**Opacity**: Decimal values from 0 to 1

```json
{
  "primitive": {
    "opacity": {
      "$type": "number",
      "50": {
        "$value": 0.5
      }
    }
  }
}
```

**Z-Index**: Integer values

```json
{
  "primitive": {
    "zIndex": {
      "$type": "number",
      "dropdown": {
        "$value": 1000
      }
    }
  }
}
```

#### Rationale

**Opacity (0-1)**:
- ✅ **CSS standard**: Direct mapping to `opacity` property
- ✅ **Platform agnostic**: All platforms use 0-1 range
- ✅ **Human readable**: Decimal format clear (0.5 = 50%)

**Z-Index (integers)**:
- ✅ **CSS standard**: Direct mapping to `z-index` property
- ✅ **Layering**: Use increments of 10, 100, or 1000 for future insertions
- ✅ **Clear hierarchy**: Larger numbers = higher in stack

#### Platform Transforms

| Platform | Transform | Output Format |
|----------|-----------|---------------|
| Web (CSS) | Direct use | `opacity: 0.5`, `z-index: 1000` |
| iOS | Direct use | `alpha: 0.5`, `zPosition: 1000` |
| Android | Convert opacity to int (0-255) | `alpha="128"` (0.5 * 255) |

#### Examples

**Opacity**:
```json
{
  "primitive": {
    "opacity": {
      "$type": "number",
      "0": { "$value": 0, "$description": "Fully transparent" },
      "10": { "$value": 0.1 },
      "25": { "$value": 0.25 },
      "50": { "$value": 0.5 },
      "75": { "$value": 0.75 },
      "100": { "$value": 1, "$description": "Fully opaque" }
    }
  }
}
```

**Z-Index**:
```json
{
  "primitive": {
    "zIndex": {
      "$type": "number",
      "base": { "$value": 0 },
      "dropdown": { "$value": 1000 },
      "sticky": { "$value": 1100 },
      "overlay": { "$value": 1200 },
      "modal": { "$value": 1300 },
      "popover": { "$value": 1400 },
      "toast": { "$value": 1500 }
    }
  }
}
```

---

## Platform Transform Summary

| Token Type | Primitive Format | Web (CSS) | iOS | Android |
|------------|------------------|-----------|-----|---------|
| **Color** | HEX `#RRGGBB` | `#3b82f6` or `rgb()` | `UIColor` | `#3b82f6` |
| **Dimension** | Pixels `16px` | `1rem` (÷16) | `16 pt` | `16dp` |
| **Font Family** | Array `["Inter", ...]` | `"Inter", sans-serif` | `UIFont` | `fontFamily="Inter"` |
| **Font Weight** | Number `700` | `font-weight: 700` | `.bold` | `textStyle="bold"` |
| **Line Height** | Unitless `1.5` | `line-height: 1.5` | `fontSize * 1.5` | `lineSpacingMultiplier` |
| **Letter Spacing** | Pixels `1px` | `0.0625em` | `1 pt` | `1dp` |
| **Duration** | Milliseconds `150ms` | `150ms` or `0.15s` | `0.15` | `150` (long) |
| **Opacity** | Decimal `0.5` | `opacity: 0.5` | `alpha: 0.5` | `alpha="128"` |
| **Z-Index** | Integer `1000` | `z-index: 1000` | `zPosition: 1000` | `elevation` |

---

## Validation Rules

1. **Colors MUST use HEX**: All color primitives must be in `#RRGGBB` or `#RRGGBBAA` format
2. **Dimensions MUST use px**: All dimensional primitives (spacing, fontSize, etc.) must use `px` unit
3. **Line heights MUST be unitless**: No px, rem, em, or % for line height
4. **Font weights MUST be numeric**: Use 100-900, not keywords
5. **Durations MUST use ms**: All duration values in milliseconds
6. **Opacity MUST be 0-1**: Decimal values only, not percentages
7. **Composite types MUST reference primitives**: Typography and shadow should reference primitive tokens
8. **Required properties**: Composite types must include all required properties per DTCG spec

---

## Consequences

### Positive

- **Consistency**: All primitives use absolute values, making transforms predictable
- **Tool compatibility**: HEX and px work seamlessly with Figma and Tokens Studio
- **Platform agnostic**: Primitives can transform to any platform requirements
- **Accessibility**: Rem transforms for web improve user preference scaling
- **Future-proof**: Supports modern CSS standards (OKLCH, composite types)
- **Flexibility**: Clear transform strategy for each platform
- **Maintainability**: Single source of truth for all values

### Negative

- **Transform dependency**: Requires build tools (Style Dictionary) for platform-specific outputs
- **Px to rem conversion**: Web developers must understand transform to rem
- **Learning curve**: Team needs to understand format decisions and transform strategy

### Risks

- **Tool configuration**: Incorrect Style Dictionary configuration could produce wrong outputs
- **Platform drift**: Platforms might use values differently if transforms aren't applied correctly
- **Rounding errors**: Transform calculations may introduce slight rounding differences

### Mitigation

1. **Clear documentation**: Document transform strategy for each platform
2. **Style Dictionary config**: Provide reference configurations for all platforms
3. **Validation**: Use linting to ensure format compliance
4. **Testing**: Verify outputs match expected values across platforms
5. **Tooling**: Automate transforms to prevent manual errors

---

## References

- [W3C Design Tokens Community Group](https://www.w3.org/community/design-tokens/)
- [Design Tokens Format Specification (DTCG 2025.10)](https://www.designtokens.org/TR/drafts/format/)
- [CSS Color Module Level 4](https://www.w3.org/TR/css-color-4/)
- [Style Dictionary Documentation](https://styledictionary.com/)
- [OKLCH Color Space](https://oklch.com/)
- [Figma Variables Documentation](https://help.figma.com/hc/en-us/articles/15339657135383-Guide-to-variables-in-Figma)
- ADR 001: Token Taxonomy
- ADR 002: Taxon Variants
